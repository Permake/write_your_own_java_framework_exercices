package com.github.forax.framework.orm;

import javax.sql.DataSource;
import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.Serial;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class ORM {
  private ORM() {
    throw new AssertionError();
  }


  @FunctionalInterface
  public interface TransactionBlock {
    void run() throws SQLException;
  }

  private static final Map<Class<?>, String> TYPE_MAPPING = Map.of(
      int.class, "INTEGER",
      Integer.class, "INTEGER",
      long.class, "BIGINT",
      Long.class, "BIGINT",
      String.class, "VARCHAR(255)"
  );

  private static Class<?> findBeanTypeFromRepository(Class<?> repositoryType) {
    var repositorySupertype = Arrays.stream(repositoryType.getGenericInterfaces())
        .flatMap(superInterface -> {
          if (superInterface instanceof ParameterizedType parameterizedType
              && parameterizedType.getRawType() == Repository.class) {
            return Stream.of(parameterizedType);
          }
          return null;
        })
        .findFirst()
        .orElseThrow(() -> new IllegalArgumentException("invalid repository interface " + repositoryType.getName()));
    var typeArgument = repositorySupertype.getActualTypeArguments()[0];
    if (typeArgument instanceof Class<?> beanType) {
      return beanType;
    }
    throw new IllegalArgumentException("invalid type argument " + typeArgument + " for repository interface " + repositoryType.getName());
  }

  private static class UncheckedSQLException extends RuntimeException {
    @Serial
    private static final long serialVersionUID = 42L;

    private UncheckedSQLException(SQLException cause) {
      super(cause);
    }

    @Override
    public SQLException getCause() {
      return (SQLException) super.getCause();
    }
  }


  // --- do not change the code above
  private static final ThreadLocal<Connection> CONNECTION_THREAD_LOCAL = new ThreadLocal<>();

  public static void transaction(DataSource dataSource, TransactionBlock block) throws SQLException {
    Objects.requireNonNull(dataSource);
    Objects.requireNonNull(block);
    try (var connection = dataSource.getConnection()) {
      CONNECTION_THREAD_LOCAL.set(connection);
      try {
        connection.setAutoCommit(false);
        block.run();
        connection.commit();
      } catch (SQLException e) {
        connection.rollback();
        throw e;
      } catch (UncheckedSQLException e) {
        connection.rollback();
        throw e.getCause();
      } finally {
        CONNECTION_THREAD_LOCAL.remove();
      }
    }
  }

  public static Connection currentConnection() {
    var connection = CONNECTION_THREAD_LOCAL.get();
    if (connection == null) {
      throw new IllegalStateException("No connection available");
    }
    return connection;
  }

  public static void createTable(Class<?> beanClass) throws SQLException {
    Objects.requireNonNull(beanClass);
    var tableName = findTableName(beanClass);
    var sqlQuery = Arrays.stream(Utils.beanInfo(beanClass).getPropertyDescriptors())
            .filter(p -> !p.getName().equals("class"))
            .map(ORM::apply).collect(
                    Collectors.joining(",\n",
                            "CREATE TABLE " + tableName + " (\n",
                            ");\n"));
    try(var statement = currentConnection().createStatement()) {
      statement.executeUpdate(sqlQuery);
    }
  }

  static String findTableName(Class<?> beanClass) {
    Objects.requireNonNull(beanClass);
    var table = beanClass.getAnnotation(Table.class);
    return table == null ? beanClass.getSimpleName().toUpperCase(Locale.ROOT) : table.value().toUpperCase(Locale.ROOT);
  }

  static String findColumnName(PropertyDescriptor property) {
    Objects.requireNonNull(property);
    var getter = getGetterMethod(property);
    var column = getter.getAnnotation(Column.class);
    return column == null ? property.getName().toUpperCase(Locale.ROOT) : column.value().toUpperCase(Locale.ROOT);
  }

  private static boolean isAutoGenerated(PropertyDescriptor property) {
    var getter = getGetterMethod(property);
    return getter.isAnnotationPresent(GeneratedValue.class);
  }

  private static boolean isId(PropertyDescriptor property) {
    var getter = getGetterMethod(property);
    return getter.isAnnotationPresent(Id.class);
  }

  private static Method getGetterMethod(PropertyDescriptor property) {
    var getter = property.getReadMethod();
    if (getter == null) {
      throw new IllegalStateException("No getter for property " + property.getName());
    }
    return getter;
  }

  private static String apply(PropertyDescriptor property) {
    var column = findColumnName(property);
    var type = property.getPropertyType();
    var typeName = TYPE_MAPPING.get(type);
    if (typeName == null) {
      throw new IllegalStateException("unknown type " + type.getName());
    }
    var notNull = type.isPrimitive() ? " NOT NULL" : "";
    var autoIncrement = isAutoGenerated(property) ? " AUTO_INCREMENT " : "";
    var primaryKey = isId(property) ? ",\n PRIMARY KEY (" + column + ")" : "";
    return findColumnName(property) + " " + typeName + notNull + autoIncrement + primaryKey;
  }

  public static <T extends Repository<?, ?>> T createRepository(Class<T> repositoryClass) {
    var beanType = findBeanTypeFromRepository(repositoryClass);
    var beanInfo = Utils.beanInfo(beanType);
    var tableName = findTableName(beanType);
    var constructor = Utils.defaultConstructor(beanType);
    return repositoryClass.cast(Proxy.newProxyInstance(repositoryClass.getClassLoader(),
            new Class<?>[] {repositoryClass},
            (proxy, method, args) -> {
            var connection = currentConnection();
              try {
              return switch(method.getName()) {
                case "findAll" -> findAll(connection, "SELECT * FROM "  + tableName, beanInfo, constructor);
                case "findById" -> findAll(connection, "SELECT * FROM " + tableName + " WHERE " + findColumnName(findId(beanInfo)) + " = ?",
                        beanInfo, constructor, args[0]).stream().findFirst();
                case "equals", "hashCode", "toString" -> throw new UnsupportedOperationException("method " + method + " not supported");
                case "save" -> {
                  var bean = args[0];
                  save(connection, tableName, beanInfo, bean, findId(beanInfo));
                  yield bean;
                }
                default -> {
                  var annotation = method.getAnnotation(Query.class);
                  if (annotation != null) {
                    yield findAll(connection, annotation.value(), beanInfo, constructor, args);
                  }
                  if (method.getName().startsWith("findBy")) {
                    var result = findAll(connection,
                            "SELECT * FROM " + tableName + " WHERE " + findProperty(beanInfo,
                                    Introspector.decapitalize(method.getName().substring(6))).getName() + " = ?",
                            beanInfo, constructor, args);
                    yield method.getReturnType() == Optional.class ? result.stream().findFirst() : result;
                  }
                  throw new IllegalStateException("WTF !");
                }
              };
            } catch (SQLException e) {
              throw new UncheckedSQLException(e);
            }
    }));
  }

  static Object toEntityClass(ResultSet resultSet, BeanInfo beanInfo, Constructor<?> constructor) throws SQLException {
    var instance = Utils.newInstance(constructor);
    for(var property: beanInfo.getPropertyDescriptors()) {
      var propertyName = property.getName();
      if (propertyName.equals("class")) {
        continue;
      }
      var value = resultSet.getObject(propertyName);
      Utils.invokeMethod(instance, property.getWriteMethod(), value);
    }
    return instance;
  }
  static List<Object> findAll(Connection connection, String sqlQuery, BeanInfo beanInfo, Constructor<?> constructor, Object... args) throws SQLException {
    var list = new ArrayList<>();
    try(var statement = connection.prepareStatement(sqlQuery)) {
      //System.err.println(sqlQuery);
      if (args != null) {  // if no argument
        for (var i = 0; i < args.length; i++) {
          statement.setObject(i + 1, args[i]);
        }
      }
      try(var resultSet = statement.executeQuery()) {
        while(resultSet.next()) {
          var instance = toEntityClass(resultSet, beanInfo, constructor);
          list.add(instance);
        }
      }
    }
    return list;
  }
  static String createSaveQuery(String tableName, BeanInfo beanInfo) {
    var properties = beanInfo.getPropertyDescriptors();
    return """
    MERGE INTO %s %s VALUES (%s);\
    """.formatted(
            tableName,
    Arrays.stream(properties).filter(propertyDescriptor -> !propertyDescriptor.getName().equals("class"))
            .map(ORM::findColumnName)
            .collect(Collectors.joining(", ", "(", ")")),
    String.join(", ", Collections.nCopies(properties.length - 1, "?"))
    );
  }

  static void save(Connection connection, String tableName, BeanInfo beanInfo, Object bean, PropertyDescriptor idProperty) throws SQLException {
    String sqlQuery = createSaveQuery(tableName, beanInfo);
    //System.err.println(sqlQuery);

    try(var statement = connection.prepareStatement(sqlQuery, Statement.RETURN_GENERATED_KEYS)) {
      var index = 1;
      for(var property: beanInfo.getPropertyDescriptors()) {
        if (property.getName().equals("class")) {
          continue;
        }
        statement.setObject(index++, Utils.invokeMethod(bean, property.getReadMethod()));
      }
      statement.executeUpdate();
      if (idProperty != null) {
        try(var resultSet = statement.getGeneratedKeys()) {
          if (resultSet.next()) {
            var key = resultSet.getObject( 1);
            Utils.invokeMethod(bean, idProperty.getWriteMethod(), key);
          }
        }
      }
    }
  }

  static PropertyDescriptor findId(BeanInfo beanInfo) {
    var propertyIds =
            Arrays.stream(beanInfo.getPropertyDescriptors())
                    .filter(ORM::isId)
                    .toList();
    return switch (propertyIds.size()) {
      case 0 -> null;
      case 1 -> propertyIds.getFirst();
      default -> throw new IllegalStateException("more than one getters is annotated with @Id");
    };
  }

  static PropertyDescriptor findProperty(BeanInfo beanInfo, String propertyName) {
    return Arrays.stream(beanInfo.getPropertyDescriptors())
            .filter(propertyDescriptor -> !propertyDescriptor.getName().equals("class"))
            .filter(propertyDescriptor -> propertyDescriptor.getName().equals(propertyName))
            .findFirst().orElseThrow(() -> new IllegalStateException("The property " + propertyName + " does not exist"));
  }
}